"use strict";
/**
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assistant_1 = require("../../assistant");
const actionssdk_1 = require("../actionssdk");
const common_1 = require("../../common");
const context_1 = require("./context");
const APP_DATA_CONTEXT = '_actions_on_google';
const APP_DATA_CONTEXT_LIFESPAN = 99;
/** @public */
class DialogflowConversation extends actionssdk_1.Conversation {
    /** @public */
    constructor(options) {
        super({
            request: DialogflowConversation.getRequest(options.body),
            headers: options.headers,
            init: options.init,
        });
        const { body, init } = options;
        this.body = body;
        if (DialogflowConversation.isV1(this.body)) {
            this.version = 1;
            const { result } = this.body;
            const { action, parameters, contexts, resolvedQuery, metadata } = result;
            const { intentName } = metadata;
            this.action = action;
            this.intent = intentName;
            this.parameters = parameters;
            this.contexts = new context_1.ContextValues(contexts);
            this.query = resolvedQuery;
        }
        else {
            this.version = 2;
            const { queryResult } = this.body;
            const { action, parameters, outputContexts, intent } = queryResult;
            const { displayName } = intent;
            this.action = action;
            this.intent = displayName;
            this.parameters = parameters;
            this.contexts = new context_1.ContextValues(outputContexts, this.body.session);
            this.query = this.body.queryResult.queryText;
        }
        for (const key in this.parameters) {
            const value = this.parameters[key];
            if (typeof value !== 'object') {
                // Convert all non-objects to strings for consistency
                this.parameters[key] = String(value);
            }
        }
        this.data = (init && init.data) || {};
        const context = this.contexts.input[APP_DATA_CONTEXT];
        if (context) {
            const { data } = context.parameters;
            if (typeof data === 'string') {
                this.data = JSON.parse(data);
            }
        }
        common_1.debug('Conversation', common_1.stringify(this, {
            request: null,
            headers: null,
            body: null,
        }));
    }
    static isV1(body) {
        return !!body.result;
    }
    static getRequest(body) {
        if (this.isV1(body)) {
            const { originalRequest = {} } = body;
            const { data = {} } = originalRequest;
            return data;
        }
        return body.originalDetectIntentRequest.payload;
    }
    /** @public */
    serialize() {
        const { richResponse, expectUserResponse, userStorage, expectedIntent, } = this.response();
        const google = {
            expectUserResponse,
            richResponse,
            userStorage,
            systemIntent: expectedIntent && {
                intent: expectedIntent.intent,
                data: expectedIntent.inputValueData,
            },
        };
        const payload = {
            google,
        };
        this.contexts.set(APP_DATA_CONTEXT, APP_DATA_CONTEXT_LIFESPAN, {
            data: JSON.stringify(this.data),
        });
        if (this.version === 1) {
            const contextOut = this.contexts.serializeV1();
            const response = {
                data: payload,
                contextOut,
            };
            return response;
        }
        const outputContexts = this.contexts.serialize();
        const response = {
            payload,
            outputContexts,
        };
        return response;
    }
}
exports.DialogflowConversation = DialogflowConversation;
/** @public */
exports.dialogflow = (options = {}) => assistant_1.attach({
    intents: {},
    middlewares: [],
    intent(intent, handler) {
        this.intents[intent] = handler;
        return this;
    },
    catch(catcher) {
        this.catcher = catcher;
        return this;
    },
    catcher(conv, e) {
        throw e;
    },
    middleware(middleware) {
        this.middlewares.push(middleware);
        return this;
    },
    handler(body, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            const { init, verification } = options;
            if (verification) {
                for (const key in verification) {
                    const check = headers[key.toLowerCase()];
                    if (!check) {
                        throw new Error('A verification header key was not found');
                    }
                    const value = verification[key];
                    const checking = common_1.toArray(check);
                    if (checking.indexOf(value) < 0) {
                        throw new Error('A verification header value was invalid');
                    }
                }
            }
            let conv = new DialogflowConversation({
                body,
                headers,
                init: init && init(),
            });
            for (const middleware of this.middlewares) {
                conv = middleware(conv);
            }
            const { intent } = conv;
            const traversed = {};
            let handler = intent;
            while (typeof handler !== 'function') {
                if (typeof handler === 'undefined') {
                    throw new Error(`Dialogflow IntentHandler not found for intent: ${intent}`);
                }
                if (traversed[handler]) {
                    throw new Error(`Circular intent map detected: "${handler}" traversed twice`);
                }
                traversed[handler] = true;
                handler = this.intents[handler];
            }
            try {
                yield handler(conv, conv.parameters, conv.arguments.list[0]);
            }
            catch (e) {
                yield this.catcher(conv, e);
            }
            return {
                status: 200,
                body: conv.serialize(),
            };
        });
    },
}, options);
//# sourceMappingURL=dialogflow.js.map