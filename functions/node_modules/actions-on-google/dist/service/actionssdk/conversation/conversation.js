"use strict";
/**
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const surface_1 = require("./surface");
const user_1 = require("./user");
const response_1 = require("./response");
const question_1 = require("./question");
const argument_1 = require("./argument");
const device_1 = require("./device");
const input_1 = require("./input");
/** @public */
class Conversation {
    constructor(options) {
        /** @public */
        this.responses = [];
        /** @public */
        this.expectUserResponse = true;
        /** @public */
        this.digested = false;
        const { request, headers, init } = options;
        this.request = request;
        this.headers = headers;
        this.sandbox = !!this.request.isInSandbox;
        const { inputs = [] } = this.request;
        const [input = {}] = inputs;
        const { rawInputs = [] } = input;
        this.input = new input_1.Input(rawInputs[0]);
        this.surface = new surface_1.Surface(this.request.surface);
        this.available = new surface_1.Available(this.request.availableSurfaces);
        this.user = new user_1.User(this.request.user, init && init.storage);
        this.arguments = new argument_1.Arguments(input.arguments);
        this.device = new device_1.Device(this.request.device);
    }
    /** @public */
    add(...responses) {
        if (this.digested) {
            throw new Error('Response has already been sent. ' +
                'Is this being used in an async call that was not ' +
                'returned as a promise to the action/intent handler?');
        }
        this.responses.push(...responses);
        return this;
    }
    /** @public */
    ask(...responses) {
        this.expectUserResponse = true;
        return this.add(...responses);
    }
    /** @public */
    close(...responses) {
        this.expectUserResponse = false;
        return this.add(...responses);
    }
    /** @public */
    response() {
        if (this.digested) {
            throw new Error('Response has already been digested');
        }
        this.digested = true;
        const { expectUserResponse } = this;
        let richResponse = new response_1.RichResponse();
        let expectedIntent;
        for (const response of this.responses) {
            if (typeof response === 'string') {
                richResponse.add(response);
                continue;
            }
            if (response instanceof question_1.Question) {
                expectedIntent = response;
                if (response instanceof question_1.SoloQuestion) {
                    // SoloQuestions don't require a SimpleResponse
                    // but API still requires a SimpleResponse
                    // so a placeholder is added to not error
                    // It won't show up to the user as PLACEHOLDER
                    richResponse.add('PLACEHOLDER');
                }
                continue;
            }
            if (response instanceof response_1.RichResponse) {
                richResponse = response;
                continue;
            }
            if (response instanceof response_1.Suggestions) {
                if (!richResponse.suggestions) {
                    richResponse.suggestions = [];
                }
                richResponse.suggestions.push(...response.suggestions);
                continue;
            }
            if (response instanceof response_1.Image) {
                richResponse.add(new response_1.BasicCard({ image: response }));
                continue;
            }
            richResponse.add(response);
        }
        const userStorage = this.user.serialize();
        return {
            expectUserResponse,
            richResponse,
            userStorage,
            expectedIntent,
        };
    }
}
exports.Conversation = Conversation;
//# sourceMappingURL=conversation.js.map